package com.tennisfolio.Tennisfolio.mock;

import com.tennisfolio.Tennisfolio.player.domain.Player;
import com.tennisfolio.Tennisfolio.ranking.domain.Ranking;
import com.tennisfolio.Tennisfolio.ranking.repository.RankingRepository;
import org.springframework.data.domain.Pageable;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;

public class FakeRankingRepository implements RankingRepository {
    private final AtomicLong autoGeneratedId = new AtomicLong(0L);
    private final List<Ranking> data = Collections.synchronizedList(new ArrayList<>());
    private final List<Ranking> buffer = Collections.synchronizedList(new ArrayList<>());
    private int batchSize = 3;
    @Override
    public Optional<Ranking> getById(Long id) {
        return data.stream().filter(item -> item.getRankingId().equals(id)).findAny();
    }

    @Override
    public Ranking save(Ranking ranking) {

        if(ranking.getRankingId() == null || ranking.getRankingId() == 0L){

            Ranking saveRanking = Ranking.builder()
                    .rankingId(autoGeneratedId.incrementAndGet())
                    .player(ranking.getPlayer())
                    .bestRank(ranking.getBestRank())
                    .preRank(ranking.getPreRank())
                    .curRank(ranking.getCurRank())
                    .curPoints(ranking.getCurPoints())
                    .prePoints(ranking.getPrePoints())
                    .lastUpdate(ranking.getLastUpdate())
                    .build();

            data.add(saveRanking);
            return saveRanking;
        }else{
            data.removeIf(item -> Objects.equals(item.getRankingId(), ranking.getRankingId()));
            data.add(ranking);
            return ranking;
        }

    }

    @Override
    public List<Ranking> saveAll(List<Ranking> rankings) {
        List<Ranking> newRankings = rankings.stream().map(ranking -> {
            if(ranking.getRankingId() == null || ranking.getRankingId() == 0L) {

                Ranking newRanking = Ranking.builder()
                        .rankingId(autoGeneratedId.incrementAndGet())
                        .player(ranking.getPlayer())
                        .bestRank(ranking.getBestRank())
                        .preRank(ranking.getPreRank())
                        .curRank(ranking.getCurRank())
                        .curPoints(ranking.getCurPoints())
                        .prePoints(ranking.getPrePoints())
                        .lastUpdate(ranking.getLastUpdate())
                        .build();
                data.add(newRanking);
                return newRanking;
            }else{
                data.removeIf(item -> Objects.equals(item.getRankingId(), ranking.getRankingId()));
                data.add(ranking);
                return ranking;
            }
        }).toList();

        return newRankings;
    }

    @Override
    public List<Ranking> findLatestRankings(Pageable pageable) {
        int start = (int) pageable.getOffset();
        int end = Math.min(start + pageable.getPageSize(), data.size());

        return data.subList(start, end);
    }

    @Override
    public List<Ranking> findByLastUpdate(String lastUpdate) {
        return data.stream().filter(item -> lastUpdate.equals(item.getLastUpdate())).toList();
    }

    @Override
    public boolean existsByLastUpdate(String lastUpdate) {
        return findByLastUpdate(lastUpdate).size() > 0;
    }

    @Override
    public List<Ranking> collect(Ranking ranking) {
        if(ranking.getRankingId() == null || ranking.getRankingId() == 0L) {
            Ranking newRanking = Ranking.builder()
                    .rankingId(autoGeneratedId.incrementAndGet())
                    .player(ranking.getPlayer())
                    .bestRank(ranking.getBestRank())
                    .preRank(ranking.getPreRank())
                    .curRank(ranking.getCurRank())
                    .curPoints(ranking.getCurPoints())
                    .prePoints(ranking.getPrePoints())
                    .lastUpdate(ranking.getLastUpdate())
                    .build();
            buffer.add(newRanking);
        }else{
            buffer.removeIf(item -> Objects.equals(item.getRankingId(), ranking.getRankingId()));
            buffer.add(ranking);
        }

        return buffer;
    }

    @Override
    public List<Ranking> collect(List<Ranking> rankings) {

        List<Ranking> newRankings = rankings.stream().map(ranking -> {
            if(ranking.getRankingId() == null || ranking.getRankingId() == 0L) {

                Ranking newRanking = Ranking.builder()
                        .rankingId(autoGeneratedId.incrementAndGet())
                        .player(ranking.getPlayer())
                        .bestRank(ranking.getBestRank())
                        .preRank(ranking.getPreRank())
                        .curRank(ranking.getCurRank())
                        .curPoints(ranking.getCurPoints())
                        .prePoints(ranking.getPrePoints())
                        .lastUpdate(ranking.getLastUpdate())
                        .build();
                buffer.add(newRanking);
                return newRanking;
            }else{
                buffer.removeIf(item -> Objects.equals(item.getRankingId(), ranking.getRankingId()));
                buffer.add(ranking);
                return ranking;
            }
        }).toList();
        return buffer;
    }

    @Override
    public boolean flushWhenFull() {
        if(buffer.size() >= batchSize){
            data.addAll(buffer);
            buffer.clear();
            return true;
        }
        return false;
    }

    @Override
    public boolean flushAll() {
        if(!buffer.isEmpty()){
            data.addAll(buffer);
            buffer.clear();
            return true;
        }
        return false;
    }
}
