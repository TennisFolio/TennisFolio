package com.tennisfolio.Tennisfolio.mock;

import com.tennisfolio.Tennisfolio.Tournament.domain.Tournament;
import com.tennisfolio.Tennisfolio.player.domain.Player;
import com.tennisfolio.Tennisfolio.prize.domain.PlayerPrize;
import com.tennisfolio.Tennisfolio.prize.repository.PrizeRepository;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

public class FakePrizeRepository implements PrizeRepository {
    private final AtomicLong autoGeneratedId = new AtomicLong(0L);
    private final Map<Long, PlayerPrize> data = new ConcurrentHashMap<>();
    private final int batchSize = 3;
    private final List<PlayerPrize> batch = Collections.synchronizedList(new ArrayList<>());
    @Override
    public List<PlayerPrize> findAll() {
        return data.values().stream().toList();
    }

    @Override
    public PlayerPrize findByPlayer(Player player) {
        return data.values().stream().filter(p -> p.getPlayer().getPlayerId().equals(player.getPlayerId())).findFirst().orElse(null);
    }

    @Override
    public void save(PlayerPrize playerPrize) {
        PlayerPrize saved = playerPrize;
        if(playerPrize.getPrizeId() == null || playerPrize.getPrizeId() == 0L){
            saved = PlayerPrize.builder()
                    .prizeId(autoGeneratedId.getAndIncrement())
                    .prizeCurrentAmount(playerPrize.getPrizeCurrentAmount())
                    .prizeCurrentCurrency(playerPrize.getPrizeCurrentCurrency())
                    .prizeTotalAmount(playerPrize.getPrizeTotalAmount())
                    .prizeTotalCurrency(playerPrize.getPrizeTotalCurrency())
                    .build();
        }
        data.put(saved.getPrizeId(), saved);
    }

    @Override
    public List<PlayerPrize> collect(PlayerPrize playerPrize) {
        batch.add(playerPrize);
        return batch;
    }

    @Override
    public List<PlayerPrize> collect(List<PlayerPrize> playerPrizes) {
        batch.addAll(playerPrizes);
        return batch;
    }

    @Override
    public boolean flushWhenFull() {
        if(batch.size() >= batchSize){
            flushBatch();
            return true;
        }
        return false;
    }

    @Override
    public boolean flushAll() {
        if(!batch.isEmpty()){
            flushBatch();
            return true;
        }
        return false;
    }

    @Override
    public void flush() {

    }

    private void flushBatch() {
        for (var prize : batch) {
            long prizeId = prize.getPrizeId();
            data.put(prizeId, prize); // 중복이면 자동 덮어쓰기
        }
        batch.clear();
    }
}
